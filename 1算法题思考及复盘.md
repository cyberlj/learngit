
leetcode 30,

     Integer a = 10; Integer b = 10; System.out.println(a==b); //返回的是true   
     Integer a = 1000; Integer b = 1000; System.out.println(a==b); //返回是false

leetcode 1046

leetcode 33 搜索旋转排序数组
# 剑指offer  
## 根据前序遍历和中序遍历来构建二叉树
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        
        //前序遍历决定了根节点。中序遍历根据根节点可以划分左右子树。
       // 但是知道了根节点，需要遍历中序数组，查找根节点的位置。
       
        if(preorder==null||inorder==null){
            return null;
        }
        return preAndmid(preorder,0,preorder.length-1,inorder,0,inorder.length-1);
    }
    public TreeNode preAndmid(int[] preorder,int preb,int pree,int[] inorder,int inb,int ine){
        if(preb>pree){
            return null;
        }
        if(preb==pree){
            TreeNode sub = new TreeNode(preorder[preb]);
            return sub;
        }

        TreeNode root = new TreeNode(preorder[preb]);
        int location = inb;
        while(location<=ine){
            if(inorder[location]!=preorder[preb])
                location++;
        }
        root.left = preAndmid(preorder,preb+1,preb+location-inb,inorder,inb,location-1);
        root.right = preAndmid(preorder,preb+location-inb+1,pree,inorder,location+1,ine);
        return root;

    }
    运行结果说超时了
## 30 包含min函数的栈  
    1. 单调栈——最小值  
    在维护一个普通栈功能的同时，要求能以O(1)的时间复杂度调取当前栈中的最小值  
    如果说在维持一个普通栈的功能时，还要以O(1)的时间复杂度调取当前栈中的最小值，那么我们必然需要一个辅助栈来实现这个功能。因此我们需要两个栈A,minA，其中栈A实现普通栈功能，minA实现求栈的最小值。  
    具体的minA如何实现求栈的最小值功能呢？  
    我们知道栈是先进后出的。如果此时minA栈中top是X，此时准备向栈中增加一个元素Y，那么我们在什么情况下来更新minA中的元素呢？ 如果Y<=X,那么需要向minA中添加Y，因为在从栈A中弹出Y之前，Y都是到目前为止的最小值。除非有新增的Z会更新了minA的top级的元素。那压入Y之前我们是否需要删除X呢，不能，因为如果删除了X，由于Y要先于X弹出，在弹出Y之后，minA中没有了弹出Y后的A中最小值X。。如果Y>X，那么我们无需向minA中压入Y，因为栈是先进后出，只有先弹出了Y，然后才会弹出X，而Y>X，因此在弹出X之前，Y永远不会是最小值。
    举例  
    分别压入 3,4,2,1，分别再从栈中依次弹出  
    |:----: |:----: |:----: |
    |A|minA|最小值|
    |3|3|3|
    |3,4|3|3|
    |3,4,2|3,2|2|
    |3,4,2,1|3,2,1|1|
    |3,4,2|3,2|2|
    |3,4|3|3|
    |3|3|3|  

    2. 单调栈——最大值  
    同样的我们需要两个栈A,maxA,其中A实现普通栈的功能，maxA实现以O(1)时间复杂度取出栈中当前最大值。  
    假设maxA中当前的最大值即栈顶元素是X，现在准备向栈A中压入Y，那么我们在什么情况下来更新maxA呢  
    其实maxA中栈顶元素表示从开始到压入maxA.top()元素之间的最大值。因此如果Y>=X，那么我们将Y也压入maxA中。那我们是否需要删除X呢，不能，因为元素Y要先于X被弹出，如果Y被弹出之后，实际中X将指示当前栈A中的最大值。如果Y<X，那么我们无需向maxA中压入Y，因为栈是先进后出，只有弹出了Y才会弹出X，因此X都将是弹出X之前栈中最大值的代表。
    分别压入 3,4,2,1，分别再从栈中依次弹出  
    |:----: |:----: |:----: |
    |A|maxA|最大值|
    |3|3|3|
    |3,4|3,4|4|
    |3,4,2|3,4|4|
    |3,4,2,1|3,4|4|
    |3,4,2|3,4|4|
    |3,4|3,4|4|
    |3|3|3|  

    3. 单调队列——最小值  
    在维持普通队列功能的同时，还能够以O(1)时间复杂度取出队列中的最小值元素。  
    显然，我们需要两个队列A,minA，其中队列A实现普通队列的功能，辅助队列minA实现以O(1)时间复杂度取出队列中最小值元素。
    在向minA队列中压入元素Y之前，首先要确保minA队列中即将位于Y之前的元素不得大于Y，如果有就在压入Y之前先将其大于Y的元素都删除，然后在压入Y。因为队列是先进先出。在弹出Y之前，前面的比Y大的元素都已经被弹出，不可能成为队列中的最小值。  
    分别压入 3,4,2,1，分别再从栈中依次弹出  
    |:----: |:----: |:----: |
    |A|minA|最小值|
    |3|3|3|
    |3,4|3,4|3|
    |3,4,2|2|2|
    |3,4,2,1|1|1|
    |4,2,1|1|1|
    |2,1|1|1|
    |1|1|1|  
    4. 单调队列——最大值  
    在维持普通队列功能的同时，还能以O(1)时间复杂度取出队列中的最大值元素  
    显然，我们需要两个队列A,maxA，其中队列A实现普通队列的功能，辅助队列maxA实现以O(1)的时间复杂度取出当前队列的最大值  
    在向对垒maxA中压入Y之前，要保证即将位于Y之前的元素都要比Y大，如果存在比Y小的元素，就在压入Y之前都将其删除。然后再压入Y，因为队列是先进先出，在弹出Y之前，位于Y之前的元素已经被弹掉，因此那些比Y小的元素不可能在Y没有弹出的情况下成为最大值。  
    分别压入 3,4,1,2，分别再从栈中依次弹出  
    |:----: |:----: |:----: |
    |A|maxA|最大值|  
    |3|3|3|
    |3,4|4|4|
    |3,4,2|4,2|4|
    |3,4,2,1|4,2,1|4|
    |4,2,1|4,2,1|4|
    |2,1|2,1|2|
    |1|1|1|


    
## 大数求余解法：  
    大数越界： 算法中如果涉及到指数函数，比如3^a，将随着a的增大而成指数增长，有可能超出int32甚至是int64的取值范围，导致返回值错误。  
    大数求余问题：在仅使用int32类型存储的前提下，正确计算x^a对p求余的值  
    解决方案：循环求余，快速幂求余。其中后者的时间复杂度更低，两种方法均基于以下求余运算规则推出：  
        $$(xy)\bigodot$$
## 回溯  

## 滑动窗口  

## 线段树求解 LCIS 问题 leetcode53

## 高质量代码——17打印从1到最大的n位数  
    **题目描述：** 输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3打印出1,2,3一直到最大的999   
    **解题思路：**  
    直觉上，我们首先需要确定n位数的最大值end，比如n=4是，最大值是9999，end=10^n-1.然后可以for循环遍历到end，首先时间复杂度为O(10^n-1)，由于该函数返回的是一个数组，所以空间复杂度为O(10^n-1)。成本太高。主要是时间复杂度。   
    直觉上忽略了一个非常重要的点，就是任何的数值类型，比如int,long,float,double都有数值范围限制。这里我们只考虑int和long，当n非常大的时候，10^n-1将非常有可能溢出。这就是典型的大数问题。对于大数问题，我们最常用的就是字符串或者数组来表达一个大数。 这里我们使用数组来表示大数。  
     
## 高质量代码——16数值的整数次方  
    高质量代码主要是代码的规范性和代码的完整性。其中代码的规范性要求具有清晰的书写，清晰的布局和合理的命名。代码的完整性要求编程时除了实现目的功能，还需要满足极端、边界输入的正确性和错误输入的容错性。因此代码的完整性在于三个方面：功能测试，边界测试和负面测试。 
    数值的整数次方：实现函数double Power(double base,int exponent),求base的expoent次方。不能使用库函数。 
    **解题思路：**首先是暴力求解，但是显然不是我们想要的解决方法。 如果我们求解x的16次方，我们可以求x^8，将x^8看成一个整体，平方，不用重复的从1次方计算到8次方。同样的x^8次方可以通过x^4次方计算。显然通过递归方法获得。 在实现了主要功能之后，考虑边界情况，x=1,n=0，n<0如何处理。 负面测试：x=0的时候,n<0，此时0将作为除数，是一种错误输入方式。同样需要处理
    ```
    class Solution {
        boolean g_InvalidInput=False;
    public double myPow(double x, int n) {
        if(x==0&&n<0){
            g_InvalidINpurt = True;
            return 0;
        }
        if(x==1||n==0){
            return 1.0;
        }
        double result = 0.0;
        if(n<0){
            result = calPow(x,-n);
        }
        else{
            result = calPow(x,n);
        }
       
        if(n<0){
            result = 1.0/result;
        }
        return result;
    }
    public double calPow(double x,int n){
        if(n==0){
            return 1.0;
        }
        if(n==1){
            return x;
        }
        double result = calPow(x,n/2);##这个地方我写n>>1竟然不通过？？非常奇怪
        result*=result;
        if((n&1)==1){
            result *= x;
        }
        return result;
    }
}
    ```

## offer 12 矩阵中的路径   
```
有语法错误，待解决
class Solution {
    int len;
    int n;
    int m;
    public boolean exist(char[][] board, String word) {
        len = word.length();
        if(len==0){
            return false;
        }
        n = board.length;
        if(n==0){
            return false;
        }
        m=board[0].length;
        if(m==0){
            return false;
        }
        char[] words = word.toCharArray();
        int[][] mark = new int[n][m];
        for(int i = 0;i<n;++i){
            for(int j = 0;j<m;++j){
                if(searchpath(board,i,j,words,mark,0)){
                    return true
                }
            }
        }
        return false;
    }
    public boolean searchpath(char[][] board,int i,int j,char[] word,int[][] mark,int pathlen){
        boolean haspath = false;
        if(i<0||i>=n||j<0||j>=m||mark[i][j]==1||board[i][j]!=word[pathlen]){
            return false;
        }
        else if(pathlen==len-1){
            return true;
        }
        else{
             mark[i][j]=1;
             ++pathlen;
             haspath = searchpath(board,i+1,j,word,mark,pathlen)||searchpath(board,i,j+1,word,mark,pathlen)||searchpath(board,i-1,j,word,mark,pathlen)||searchpath(board,i,j-1,word,mark,pathlen);
        }
        
        if(!haspath){
            --pathlen;
            mark[i][j]=0;
        }
        return haspath;
       
        
    }
}
```
## 排序算法比较
    **1. 快速排序**  
    快速排序使用了分治思想，分为三步分治过程。A[l,p-1],A][p]和A[p+1,r]  
    通过递归条用快速排序，对子数组A[l.p-1]和A[p+1,r]再进行排序。  由于子数组都是原址排序的，所以不需要合并操作。  
    快速排序的运行时间依赖于划分是否平衡，而平衡与否又依赖于划分的元素。如果划分是平衡的，那么快速排序算法性能和归并排序一样，而如果划分是不平衡的，那么
    快速排序的性能就接近插入排序。  
        划分平衡：如果快速排序每次返回的索引下表都能够将原数组划分成2个相同长度的子数组，即p==[l+r]/2，那么快速排序的时间复杂度为T(n)=T(n/2)+O(n)+T(n/2)，其中O(n)是找到找返回值需要的时间复杂度，即partition函数的时间复杂度（荡秋千）。根据主定理，T(n)=2T(n/2)+O(n)=O(nlogn  
        划分不平衡：最坏情况下每次递归返回的索引下标都将原数组划分成n-1个元素和0个元素这种极不平衡的状态，那么快速排序的时间复杂度为T(n)=T(n-1)+O(n)=O(n^2)，比如原本就是有序的数组或数组中所有元素值都一样，返回的索引下表是数组两端中的一个下标，使用快速排序法会导致O(n^2)的时间复杂度。
    
    虽然快速排序的最好时间是O(nlogn)最差时间复杂度是O(n^2),但是快速排序的平均运行时间更接近最好的情况。例如每次递归都是以9:1比例划分，那么T(n)=T(n/10)+T(9n/10)+O(n)，更具主定理，最终T(n)依然是O(nlogn)，其实即使是99:1的比例划分，其时间复杂度仍然是O(nlogn)。**事实上，任何一种常数比例的划分都会产生深度为O(lgn)的递归树*，其中每一层的代价都是O(n)，所以，只要划分是常数比例，算法的运行时间总是O(nlogn)**  
    总结快速排序的  
    额外空间消耗：O(logn)递归层数  
    平均时间复杂度 O(nlogn) 
    最差时间复杂度 O(n^2)  
    快速排序偏向对十分无序的数组进行排序，而一旦是那种有序的数据，性能会受很大的影响。为了降低这种不平衡性，我们在程序中引入随机化。采用一种**随机抽样**的随机化技术。与始终采用A[r]作为主元素不同，随机抽样是从子数组A[p,r]中随机选择一个元素作为主元。为了达到这个目的，首先将A[r]与从A[p,r]中随机选出的一个元素交换。通过对序列p~r的随机抽样，我们可以保证主元素x=A[r]是等概率的从r-p+1中选择的。因为主元元素是随机选取的，我们期望在平均情况下对输入数据的划分是比较均衡的。
    ```java
    public void quicksort(int[] array,int l,int r){
        if(l>=r){
            return
        }
        int q = partition(array,l,r);
        if(q>l)
            quicksort(array,l,q-1);
        if(q<r)
            quicksort(array,q+1,r);
    }

    public int random_partion(int[] array, int left, int right){
        int index = RandomInRanger(left,right);
        swap(nums[index],nums[right]);
        
        int i = left-1;
        for(index=left;index<right;++index){
            if(nums[index]<nums[end]){
                ++i;
                if(i!=index){
                    swap(nums[i],nums[index])
                }
            }
            ++i;
            swap(nums[i],nums[end]);
            return i;
        }
    }

    或者荡秋千
    public int swing(int[] array,int left,int right){
        int i=left;
        int j=right;
        int mark = array[left]
        while(i<j){
            while(i<j&&array[j]>=mark) j--;
            if(i<j){
                array[i++]=array[j];
            }
            while(i<j&&array[i]<=mark) i++;
            if(i<j){
                array[j--]=array[i];
            }
        }
    nums[i]=mark;
    return i;

    ```
## 39数组中出现次数超过一半的数字 
    题目描述：数组中有一个数组出现的次数超过数组长度的一半，请找出这个数字  
    例如[1,2,3,2,2,2,5,4,2]  输出2  
    **解题思路：**  
    1. 如果存在一个数字，其数量超过的数组长度的一半，那么对数组排序之后，该数字必然出现在n/2位置。因此我们可以使用快速排序法，来找到n/2位置上的数字。但是之中方法将改动数组中的元素。时间复杂度为O(n)  (时间复杂度不是O(N))
    2. 如果要求不能改动数组，该如何查找到呢？输入一个数字出现的次数超过了数组的一半，那么其他数组出现的次数之和都小于该数字出现的次数。因此我们可以借助这个特点来解决。使用两个变量，一个变量保存数组中一个数字，一个变量用于计数，当当前数字与下一个数字不相等时，count减去1，如果相等，那么count加一。如果count减到0，那么重新令count=1 
    ```
    //快速排序O(n) 改动数组
    class Solution{
        public int majorityElement(int[] nums){
            int n=nums.length;
            int median = n>>1;
            int low=0;
            int high = n-1;
            int index=partition(nums,low,high);
            while(index!=median){
                if(index>median){
                    high = index-1;
                }
                else{
                    low=index+1;
                }
                index=partition(nums,low,high);
            }
            return nums[median];
        }
    }

    ```

    ```
    //计数法O(n) 不改动数组（推荐）
    class Solution{
        public int majorityElement(int[] nums){
            int n = nums.length;
            int majority = nums[0];
            int count=1;
            for(int j=1;j<n;++j){
                if(count==0){
                    majority = nums[j];
                    count=1;
                }else if(nums[j]!=majority){
                    --count;
                }else{
                    ++count;
                }

            }
            return majority;
        }
    }
    ```

## leetcode 215数组中的第K个最大元素 
    **题目描述： ** 在未排序的数组中找到第K个最大的元素。请注意，你需要找的是数组排序后的第K个最大的元素，而而是第k个不同的元素  
    **解题思路：** 
    1. 快速排序法 同上一题39  
    2. 堆排序： 建立一个只有K个元素的最小堆，例如初始化数组中前K个数为最小堆，然后遍历数组后续的元素，每一次都与堆顶元素比较，如果数组A[i]>A[1]，则替换掉A[1]，重新构建最小堆,如果A[i]<=A[1]，则遍历下一个元素。遍历结束后，返回对顶元素，即是第K大元素。在实现堆排序之前，先介绍堆。见如下：  
        1. 堆排序的时间复杂度为O(nlogn). 堆排序具有空间原址性：任何时候都只需要常数个额外的元素空间存储临时数据。  
        2. “堆”数据结构不仅用在堆排序中，还可以用于构造有效的优先队列。  
        3. 一般的，在堆排序算法中，我们使用的是最大堆，最小堆通常用于构造优先队列。 
        4. “堆”数据结构一般有这几种操作  
            1. Max_Heapify(A,i，heapsize)，将下标i所在元素调整到一个适当的位置，维护“最大堆”性质   
            ```
            public void maxHeapify(int[] A,int i,int heapsize){
                int left = i*2+1;
                int right = i*2+2;
                int largest = i;
                if(left<heapsize&&A[left]>A[largest]){
                    largest = left;
                }
                if(right<heapsize&&A[right]>A[largest]){
                    largest = right;
                }
                if(largest!=i){
                    swap(A,i,largest);
                    maxHeapify(A,largest,heapsize)
                }
            }
            ``` 
            maxHeapify函数的时间代价保护：调整A[i],A[left(i)],A[right(i)]关系的时间代价为O(1),再加上一棵以i的一个孩子为根的子树上运行maxHeapify函数的时间（这里假设递归会发生）。以为每个孩子的子树的大小最多为2n/3(最坏情况发生在树的最底层恰好半满的时候)所以maxHeapify的时间复杂度为T(n)<=T(2n/3)+O(1)。根据主定理，T(n)=O(logn)，其实就是树高时间O(h)  
            2. buildMaxHeap 建堆 自低向上调用maxHeapify。对于一个A[0..n-1]的数组建立一个堆，将有0~(heapsize-1)/2个非叶子节点，而(heapsize-1)/2+1~heapsize-1索引下的元素都是叶子节点。因此我们自下而上的调整每个非叶子节点所在树使其维护一个maxHeapify特性就好。  
            ```
            public void buildMaxHeap(int[] A,int heapsize){
                for(int i = (heapsize-1)/2;i>=0;i--){
                    maxHeapify(A,i,heapsize);
                }
            }
            ```  
            由于每次调用maxHeapify需要O(logn)的时间，buildMaxHeapify执行一个for循环，故总的时间复杂度为O(nlogn)  
            3. heapSort堆排序算法。首先利用buildMaxHeap将输入数组A[0..n-1]构建出一个大小为n的最大堆,其中n=A.length。初始化好最大堆后，执行以下步骤，输出排序结果  
            + 输出A[0]当前最大元素  
            + 交换A[0]与A[n-1] 然后删除堆尾元素即原来的A[0]元素，这通过heapsize--完成
            + 调用maxHeapify(A,0,heapsize)调整最大堆
            + 循环上面3个操作，直到堆为空  
            ```
            public void heapsort(int[] A){
                int heapsize = A.length;
                buildMaxHeap(A,heapsize);
                for(i = A.length-1,i>=1;i--){
                    print(A[0]);
                    swap(A,0,i);
                    heapsize--;
                    maxHeapify(A,0,heapsize);
                }
                print(A[0])
            }
            ```  
        5. 优先队列与堆——基于最大堆实现最大优先队列  
            1. heapMaximum(A){
                return A[0]
            }  
            2. heap_extract_max(A,heapsize){
                int max = A[0];
                int n = A.length;
                A[0]=A[heapsize];
                heapsize--;
                maxHeapify(A,0,heapsize);
            }  
            3. heapIncreaseKey(A,i,key){
                if(key<A[i]){
                    print("key is smaller than the current key")
                }
                A[i] = key;
                while(i>0&&A[parent(i)]<A[i]){
                    swap(A,i,parent(i));
                    i = parent(i);
                }
            }  
            4. maxHeapInsert(A,key,heapsize){
                heapsize++;
                A[heapsize]=-inf;
                heapIncreaseKey(A,heapsize,key)
            }
        ```
        自定义最小堆实现查找第K大元素
        class Solution {
            public int findKthLargest(int[] nums, int k) {
                int heapsize = k;
                buildMinHeap(nums, heapsize);
                for(int i = k;i<nums.length;++i){
                    if(nums[i]>nums[0]){
                        swap(nums,0,i);
                        minHeapity(nums,0,heapsize);
                    }
                }
                return nums[0];
            }
            public void buildMinHeap(int[] nums,int heapsize){
                    for(int i=(heapsize-1)/2;i>=0;--i){
                        minHeapity(nums,i,heapsize);
                    }
                }

            public void minHeapity(int[] nums,int i, int heapsize){
                int l = i*2+1;
                int r = i*2+2;
                int largest = i;
                if(l<heapsize&&nums[l]<nums[largest]){
                    largest = l;
                }
                if(r<heapsize&&nums[r]<nums[largest]){
                    largest = r;
                }
                if(largest!=i){
                    swap(nums,largest,i);
                    minHeapity(nums,largest,heapsize);
                }
            }
            public void swap(int[] nums,int i,int j){
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }
        ```  
        ```
        使用java中优先队列  该实现对应着剑指offer40 最小的k个数  
        class Solution {
            public int[] getLeastNumbers(int[] arr, int k) {
                int[] vec = new int[k];
                if(k==0){
                    return vec;
                }
                PriorityQueue<Integer> queue = new PriorityQueue<Integer>(new Comparator<Integer>(){
                    public int compare(Integer num1,Integer num2){
                        return num2-num1;
                    }
                });//最大优先队列？？
                for(int i=0;i<k;i++){
                    queue.offer(arr[i]);
                }
                for(int i=k;i<arr.length;++i){
                    if(queue.peek()>arr[i]){
                        queue.poll();
                        queue.offer(arr[i]);
                    }
                }
                for(int i = 0;i<k;i++){
                    vec[i] = queue.poll();
                }
                return vec;
            }
        }
        ```

## 03数组中重复的数字  考察对一维数组的理解及分析问题的能力  
   
    一维数组占据连续的内存空间，其时间效率高而空间效率低。哈希表就是借助数组时间效率优点而设计的。
    

    1. ** 题目描述 ** 在一个长度为n的数组nums里所有数字都在0~n-1范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如  
    输入[2,3,1,0,2,5,3]  
    输出 2或3  

    **解题思路**   
    1.1 首先暴力求解，两次遍历循环，首先遍历数组，对于每个当前的元素，再遍历其后面的元素看是否与其重复若重复则退出循环，返回当前元素。  
    时间复杂度为O(n^2)  
    空间复杂度为O(1)  
    
    1.2. 哈希表: 将数组中的元组作为key，元素的数量count作为value，一旦有一个元素的value为2,则返回key。  
    同样需要遍历数组，又因为哈希表每次操作是O(1)时间复杂度，故总的时间复杂度为O(n)  
    空间复杂度，由于需要借助哈希表，所以空间复杂度为O(n);  
    
    3.当问题复杂时，能不能找到具体的例子找出其规律。我们发现题目给出的数组和有特点，数组长度为n，而所有数组都在0~n-1的范围里。如果没有重复数字，那么对其排序，其数组中的数字必定等于数组索引值。即nums[i]=i。因此我们可以对该数组排序，排序后如果和索引不相等，则是重复元素。但是数组排序的时间复杂度是O(nlogn)。  
        我们是否有更加高效的方法呢？  
        遍历数组，对当前元素如果与索引相等，则跳转到下一个元素，如果不相等，则判断以该元素为索引下的值是否等于该元素，如果相等，则表示是重复元素，如果不相等，则交换这两个值，从未使该元素到自己索引位置上。以此循环，一旦找到重复数字，即可退出。  
        时间复杂度： 遍历数组是O(n)的时间，每个元素操作最多不超过两次。（思考为什么），因此时间复杂度为O(n)  
        空间复杂度为O(1)  
        为什么每个元素操作最多不超过两次？  
        每个元素操作主要在判断元素是否与当前索引相等，最坏的情况是不相等，则交换两个位置，该元素操作1次，另一个元素也操作1次，而另一个元素最坏的情况是交换之后，该元素依然与当前元素不相等，所以在此交换，将自己放到对应的索引下，放到正确的索引下后，该元素就不会再被改动。因此最坏的情况是交换2次。 

    2. 不修改数组找出重复数字
        **题目描述： **在一个长度为n+1的数组里的所有数字都在1~n的范围里，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字。但是不能修改输入的数组。
        **解题思路： **由于不能修改数组，所以不能对原始数组排序，当然可以创建一个辅助空间，将每个元素m复制到下表m的位置，这样就能够发现重复数字，当然也可以借助哈希表。但是这两种方式的时间复杂度和空间复杂度都是O(n)  
        以上还不是最佳的解题方法。n+1长度的数组中元素的范围介于0~n之间。如果以中间数字m将数组划分成两个部分，一个数组中的元素值都都1~m，另一个是m+1~n，如果1~m范围内的元素个数大于m则，否则存在另一个数组中。因为假设1~m范围内没有重复数字，那么数量必然不会超过m，如果超过则必然有重复数字。  


***
## 04 二维数组中的查找  考察对二维数组的理解  
    **问题**在一个n*m的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序，请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。  
    **解题思路**   
    1. 暴力求解  
        遍历每一行，对每一行都进行二分查找，遍历每一个行是O(n)，每一行二分查找是O(logm)，因此总时间复杂度为O(nlogm) 空间复杂度为O(1)  
    2. 以具体例子来找出复杂问题的规律。充分利用每一行与每一列递增的特点。 
        以一个矩阵的中间元素为例，nums[i,j],  
        如果nums[i,j]<target，则下一步它既可以向右走，又可以向下走，那么有重叠的区域。如何避免去考虑重叠区域呢 ，那就从四个角开始查找，从而避免重叠区域。经具体例子分析，左上角有右下角都不可行，而左下角和右上角都可以。以右上角为例。 
        如果nums[0][n]<target，由于行从小到大排列，故可以排除这一行。  
        如果nums[0][n]>target,由于列从小到大递增，故可以排除这一列。  
        从而不断缩小范围。  
        时间复杂度O(n+m)，因为每经过一次判断，要么排除一行，要么排除一列，做坏的情况是，遍历了一行和一列，加起来是n+m次，因此时间复杂度为O(n+m) 
        空间复杂度O(1)
## 07 旋转数组中的最小值  
    **问题描述：** 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组[3,4,5,1,2]为[1,2,3,4,5]的一个旋转，该数组的最小值为1.  
    注意这里不是严格递增数组，可以有重复的数组。  
    例如[2,2,2,0,1]  输出0  
    
    **解题思路：**  
    1. 暴力求解，遍历一遍数组就能有返回值，时间复杂度为O(n)，但是这没有用到递增旋转数组的特点。  
    2. 分情况讨论。  
    特征旋转数组，将原数组划分成两个递增子数组。一般当数组是排序好的时候，往往使用二分法。同样使用两个指针，左端和右端。现在考虑中间元素和右端元素值。  nums[mid]与num[right]  
    当nums[mid]>num[right]时，说明最小值位于右边数组中，可另left = mid+1  
    当nums[mid]<num[right]时，说明最小值位于mid的左边，可另right = mid 
    当nums[mid]==nums[right]时，我们无法判别最小值位于哪边，由于两者相等，所以无论nums[high]是不是相等，都有一个它的[替代品],因此我们可以让右端旨在向左边移动一个位置。  

    我们要考虑，当满足第二种情况时，令right=mid，是否会导致最终死循环呢？  
    二分查找的中断条件是left>=right，由于mid是(left+right)/2向下取整，所以最终当只有两个元素时，mid会指向left，而满足条件2的时候，right=mid，此时right==left，则不会死循环。  
    
    以上是将mid于right元素值进行比较，我们看看能不能让mid与left比较：  
    如果nums[left]<nums[mid]：说明最小值位于mid的右边，我们令left = mid+1.但是这种情况我们要注意旋转数组只旋转0个元素，即依然保持原数组的样子[1,2,3,4,5]，这种情况最小值位于nums[0]，所以针对这种情况，我们单独处理。  
    如果nums[left]>nums[mid] 说明最小值位于mid的左边，我们令right =mid  
    如果nums[left]==nums[mid]，则将left向右移动一个位置
    与左边left比较时，while()的判断条件很严格，需要设置为left<right**nums[left]>=nums[right]


## 二叉树的4种遍历7种方法 
 
    1. 前序遍历_递归
    2.
    3.
    4.
    5. 后序遍历_递归  
    ```C++
    void PostOrder(BiTree* root){
        if(root==null){
            return;
        }
        PostOrder(root->lchild);
        PostOrder(root->rchild);
        print(root->val);
    }
    ```  
    6. 后续遍历_循环  
        第一种思路：对于任一节点P，将其入栈，然后沿其左孩子一直往下搜索，直到没有左孩子。此时该节点出现在栈顶位置。但是此时还不能将其出栈并访问，因为其右孩子还没有被访问。因此返回栈顶元素，指向该元素的右孩子，重复上述过程。当访问完右孩子时，该节点又出现在栈顶，此时可以将其出栈并访问。可以看出，在这个过程中，每个节点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要设置一个变量表示该节点是否是第一次出现在栈顶。  
        ```C++
        void PostOrder(BiTree* root){
            BiTree* p=root;
            Stack<BiTree*> s;
            while(p!=null||!s.isEmpty()){
                while(p!=null){
                    while(p!=null){
                    s.push(p);
                    p=p->lchild;
                    }
                    p=p->rchild;
                }
                if(!s.isEmpty()){
                    p = p.pop()
                    print(p.val);
                }
                if(!s.isEmpty()){
                    p=s.top();
                    p=p->rchild;
                }
                
                }
            
        }

        ```

        第二种思路： 要保证根节点在左右孩子访问之后才能访问，因此对于任一节点P，先将其入栈。如果P没有左右孩子，则可以直接访问。或者P存在左右孩子，但是左右孩子已经被访问，也可以直接访问P。若非上述两种强开，则将P的右孩子和做孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子签名访问，左孩子和右孩子都在根节点前面被访问。

 



***
# 排序——中等
## **56合并区间**
    **题目：** 给出一个区间的集合，请合并所有重叠的区间。  
    例1： 输入intervals=[[1,3],[2,6],[8,10],[15,18]  
          输出[[1,6],[8,10],[15,18]]  
          其中intervals[i][0]《=intervals[i][1]  
    **解题思路**  
    对于这二维数组，按每个子数组的第一个数字排序，这样紧挨着的子数组将有可能是重叠的.比如排序后的结果为[[0,4],[0,3],[0,5],[1,6],[4,7]]，然后遍历该数组，arr[i][0]与arr[i-1][1]比较，如果arr[i][0]<=arr[i-1][1]，那么修改arr[i-1][1],arr[i][1]=max(arr[i-1][1],arr[i][1])，且修改arr[i][0]=arr[i-1][0]。如果arr[i][0]>arr[i-1][1]，则说明两个区间时分隔的，那么将arr[i-1]添加到结果数组中，遍历结束后，要将arr[n-1]也要添加到数组中。
***
## **75颜色分类**  
    **题目：** 给定一个包含红，白，蓝三种颜色，一共n个元素的数组，**原地**对它们进行排序，使得相同颜色的元素相邻，并且按照红色，白色，蓝色顺序排列。此题中用整数0,1,2分别表示红色，白色和蓝色。  
    **解题思路**  
    方法一：遍历数组，count每种颜色的个数，然后对元素组，按各自的个数直接输入0,1,2。  
    该方法简单明了，时间复杂度为O(n)  
    方法二: 对于三种数字，如果我们排列好0和2，那么1也肯定排列好。因为找到0的有边界和2的左边界是关键。使用双指针分别指示0当前有边界和2当前左边界。遍历数组，当arr[i]=0时，swap(arr[r0],arr[i])，然后r0向后移动，并且i也向后移动，因为i从左向右移动保证了i的左边区间时按0~1排列的，当arr[i]=2时,swap(arr[left2],arr[i])，left2向左移动。
***
## **179最大数**
    **题目** 给定一组非负整数，重新排列他们的顺序使之组成一个最大的整数。  
    例如[10,2] 输出210，比如[3.30.34.5.9]，输出9534330。输出结果可能非常大，所以你需要返回一个字符串而不是整数。 
    **解题思路** 根据题目要求，最高位数字越大越好，如果只是对数组中元素按首字母从大到小排列，会有错误。比如[3,34,30]排序成[34,30,3]得到的是34303，但是34330是目标结果。在这里，我们需要对两两数字的组合进行比较。比如给定数字a,b将其转换成字符串，进行拼接。然后比价a+b和b+a，如果a+b>b+a，那么认为a>b，即a位于b的前面。将数组排列好之后，如果第一个数字为0，即组成的字符串的高位为0，则直接返回0。  
***    
## 74 搜索二维矩阵
    **题目：** 编写一个高效的算法来判断m*n矩阵中，是否存在一个目标值。该矩阵局域如下特性:
        每行中的整数从做到右按升序排列
        每行的第一行整数大于前一行的最后一个整数。  
    输入  
    maxtrix=[[1,3,5,7,10,11,16,20,23,30,34,50]];  
    target = 3
    true  
     

    
***        
# 排序——简单

## **242有效的字母的异位词**  

    **题目:** 给定两个字符串s,t，如果s和t中存在的字母都一样，包括个数也相同，则t是s的字母异位词。比如s="anagram"，t="nagaram"  
    **解题思路:**  
    哈希表算法，利用一个哈希表，其key为字符串s的值，value是相应字母在字符串中的个数。相应的也用一个哈希表存储字符串s的值。然后比较这两个哈希表中value是否相同。进一步优化，可以只用一个哈希表，在映射字符串s的时候，对value进行“++”操作，映射字符串t的时候，对value进行“--”操作，最后检查哈希表中的value，如果存在不等于0的元素，则表示不是词异位，而所有元素值都为0，则表示两个字符串是异位词。   
    时间复杂度: $$O(m+n)$$  
    空间复杂度：O(26) 
***

## **349两个数组的交集:**  
    **题目：** 给定两个数组，编写一个函数来计算他们的交集,比如nums1=[1,2,2,1],nums2=[2,2],输出：[2]. 
    **解题思路**  
    这里就是要求实现一个交运算。首先将数组转换成set集合数据结合,java中提供一个contains函数以时间复杂度O(1)检查集合中是否存在指定的元素.即在转换成集合之后，迭代较小的集合，检查其中的每一个元素是否同样存在于较大的集合中。    
    时间复杂度:O(m+n)  
    空间复杂度:O(m+n)使用两个集合  
***
## **250两个数组的交集II**  
    **题目：** 给定两个数组，编写一个函数来计算他们的交集，要求：输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致，可以不考虑输出结果的顺序。这与第249到题目不同，不是集合的交集元素，要求元素只出现1次即可。这是数组的交集运算，允许存在重复值，如nums1=[2,2,2]，nums2=[2,2]，输出[2,2].  
    **解题思路：**  
    哈希表方法，使用一个哈希表，先对较短的数组进行映射，哈希表的key是数组中的值，哈希表的value是每个数据出现的次数。在对较长的数组进行映射，每次映射检查对应的value值，如果值大于0，就添加到输出数组中，之后进行“--”操作，若值小于等于0，就从哈希表中删除该值key。
***
## **922按奇偶排序数组**  
    **题目** 给定一个非负整数数组A,其中A中一般奇数，一半偶数，对数组进行排序，以便当A[i]为奇数的时候，下表i也为奇数，当A[i]为偶数的时候，i也为偶数。  
    **解题思路**  
    方法1： 借助空间，创建一个空的数组T，遍历数组A，依次将A中的奇数存放在T[1],T[3]。。。,将偶数存在T[0],T[2]。。。时间复杂度O(n),空间复杂度O(n)  
    方法2: 这种题目，面试官肯定要求不要额外的空间来实现。遍历A，遍历到索引i的时候，要求i之前对应奇数位存在奇数，偶数位存放偶数。此时需要双指针实现。当偶数位正确存放的时候，奇数位也必定存放正确。
***
## **976三角形的最大周长**  
    **题目** 给定由一些正数（代表长度）组成的数组A，返回由其中三个长度组成的，面积不为0的三角形的最大周长。如果不能形成三角形，返回0.  
    **解题思路**  
    三角定理，任意一边不大于其他两边之和即，a<b+c，要求周长最长，当其中一条边a确定时,b+c越大越好。因此对数组A按从大到小排序。当当前数值的后面两个数值之和大于该值时，则返回三个数之和。当遍历所有的A之后，就返回0，表示无法形成三角形。  

***
## **1030 距离顺序排列矩阵单元格**
    **题目**: R行C列矩阵，给出一个坐标为(r0,c0)，按照曼哈顿距离从小到大给其他坐标点排序。
    **方法** 使用二维数组存储坐标的下表值，遍历二维数组，计算坐标与(r0,c0)的距离，并按其排序。

***  
## **1122数组的相对排序**  
    $\color{red}{重要}$
    **题目:** 给你两个数组，arr1和arr2，其中arr2中的元素各不相同，且其中每个元素都出现在arr1中。现在要求度arr1中元素进行排序，使arr1中元素的相对顺序和arr2中的相对顺序一样，不在arr2中出现过的元素要求按照升序放在arr1的尾部。例如：  
    输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]  
    输出：[2,2,2,1,4,3,3,9,6,7,19]  
    **方法1：**计数排序法  
     定义一个数组count计算出现在arr2中的arr1元素个数，count下标表示arr1与arr2中元素值，因为题目中给出arr1与arr2中元素在[0,1000]范围里，故定义一个1001长度的count，利用count下标，从而实现了没有出现在arr2中的arr1的元素进行升序排列。具体的步骤是：首先遍历arr1数组，统计arr1中各个元素出现的次数。然后遍历arr2数组，抽取中arr2中相应元素的count，覆盖arr1中count个arr2中元素值。之后再遍历数组count,检查是否还存在不为0的元素，若有，直接提取出即可，保持了升序的顺序。
    
    **方法2**:自定义排序比较  
    定义一个HashMap，key是arr2中的元素，value是元素对应的下表索引。遍历arr2初始化好map，然后遍历arr1，两元素进行比较num1,与num2
        + 如果num1和num2都是map中的key，则比较其value，也就是num1和num2在arr2中的下表。
        + 如果num1是map的key，而num2不是map的key，则num1大
        + 如果num1不是map的key,而num2是map的key，则num2大
        + 如果num1和num2都不是map的key，则比较num1和num2，
    定义好比较函数之后，就可以使用排序算法，首先介绍快速排序法。  
    **快速排序**  
    快速排序相当于荡秋千，先拔出一个萝卜，然后荡秋千的遍历完数组，最后将这个萝卜放在一个其左边萝卜都小于该萝卜，右边的萝卜都大于该萝卜。一轮循环之后，采用分治算法，处理该萝卜的左右两个区间，再类似的荡秋千安插萝卜。鉴于该排序算法非常重要，现在写一个普世的快速排序算法。  
    ```java
    main(){
        quickSort(arr,0,n-1);
    }
    public int[] quickSort(int[] arr,int l,int r){
        if(l>=r) return;//退出递归
        int temp = partition(arr,l,r);//该循环下萝卜适合安插的地方
        quickSort(arr,l,temp-1);//左区间递归
        quickSort(arr,temp+1,r);//右区间递归
    }
    public int partition(int[] arr, int l,int r){
        int i=l;
        int j=r;
        int mark=arr[i];
        while(i<j){
            while(i<j&&arr[j]>mark)
                j--;
            if(i<j){
                arr[i]=arr[j];
                i++;
            }
            while(i<j&&arr[i]<mark){
                i++;
            }
            if(i<j){
                arr[j]=arr[i];
                j--;
            }
        }
        arr[i]=mark;
        return i;
    }
    ```

    **方法3**归并排序
    归并排序就是将N长的数组不断的缩小区间，使各个区间呈有序数组，最后再合并有序数组（分治法）。而快速排序是不断的将哨兵安排到合适的位置，再从哨兵两侧再寻找合适的位置安插哨兵。每个过程都使左侧的数小于哨兵，右侧的数大于哨兵即可。（分治法）。如果将递归分为两个阶段：进与出，那么归并排序在“退出”的时候实现了有序排列。快速排序是在“进入”的时候实现了有序排列。  
    ```java
    public int[] main(int[] arr){
        int n=arr.length
        
       MergeSort(arr,0,n-1)
        
    }

    public void MergeSort(int[] arr, int l,int r){
        if(l>=r) return
            int mid = l+(r-l)/2;
            MergeSort(arr,l,mid);
            MergeSort(arr,mid+1,r);
            MergeArry(arr,l,mid,r);
        
    }
    public void MergeArry(int[] arr,int l,int mid, int r){
        int[] p= new int[r-l+1];
        int i=l;
        int m = mid;
        int j=mid+1;
        int n=r;
        int k=0;
        while(i<=m&&j<=n){
            if(arr[i]<arr[j]){
                p[k++]=arr[i++];
            }
            else{
                p[k++]=arr[j++];
            }
        }
        while(i<=m){
            p[k++]=arr[i++];
        }
        while{j<=n}{
            p[k++]=arr[j++];
        }
        for(int i = 0;i<k;i++){
            arr[l+i]=p[i];
        }
    }


    ```
***

## 179最大数(中等)不会
    **题目** 给定一组非负整数，重新排列他们的顺序使之组成一个最大的整数  
    例1： 输入[10,2], 输出210  
    例2： 输入[3,30,34,5,9] 输出9534330  
    输出的结果可能非常大，所以需要返回一个字符串而不是一个整数

    **解题思路**  
    为了构建最大数组，希望越高位的数字越大越好  
    首先，要将每个整数变成字符串，然后进行排序。如果仅按降序排列，有相同的开头数字的时候会出现问题。例如，在样例2中，如果按照降序，得到的数字是[9,5,34,30,3]即9534303.然后交换3和30的位置就能得到正确答案了。因此，在每一对数在排序的比较过程中，我们比较两种连接顺序哪种会更好。我们可以证明这样的做法是正确的：  
    虽然仅仅是一道中等难度的题，但是一开始还是有点懵的，最开始的想法设计一个类似从高位开始的基数排序。但是在处理不同位长数的排序时，我发现很难给出一个统一的大小判别规律。例如962,96,9的最优排序是996962，而162,16,1最优排序是162161.  
    下面证明字符串拼接比较大小的正确性  
    1. 传递性  
        cmp(s1,s2)和cmp(s2,s3)-->cmp(s1,s3)  
        证明，假设s1,s2,s3长度分别为l1,l2,l3（此处指的是数长的10次幂，例如1的长度为10^1,99的长度为10^2，999的长度为10^3，对应数分别为n1,n2,n3



## 递归，回溯，排列组合问题



